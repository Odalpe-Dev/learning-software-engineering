# Cohesi√≥n y Acoplamiento en el Dise√±o de Software

## √çndice

1. [Introducci√≥n](#introducci√≥n)
2. [Cohesi√≥n](#cohesi√≥n)
   - [Tipos de Cohesi√≥n](#tipos-de-cohesi√≥n)
   - [Beneficios](#beneficios-de-la-alta-cohesi√≥n)
3. [Acoplamiento](#acoplamiento)
   - [Tipos de Acoplamiento](#tipos-de-acoplamiento)
   - [Beneficios del Bajo Acoplamiento](#beneficios-del-bajo-acoplamiento)
4. [Relaci√≥n entre Cohesi√≥n y Acoplamiento](#relaci√≥n-entre-cohesi√≥n-y-acoplamiento)
5. [Ejemplos Pr√°cticos](#ejemplos-pr√°cticos)
6. [Buenas Pr√°cticas](#buenas-pr√°cticas)
7. [M√©tricas](#m√©tricas)
8. [Referencias](#referencias)

## Introducci√≥n

La cohesi√≥n y el acoplamiento son dos principios fundamentales en el dise√±o de software que, cuando se aplican correctamente, conducen a sistemas m√°s mantenibles, flexibles y robustos. Estos conceptos est√°n estrechamente relacionados y generalmente se busca maximizar la cohesi√≥n mientras se minimiza el acoplamiento.

## Cohesi√≥n

La cohesi√≥n se refiere al grado en que los elementos dentro de un m√≥dulo est√°n relacionados entre s√≠ y trabajan juntos para cumplir un prop√≥sito espec√≠fico y bien definido. Es una medida de cu√°n enfocadas y relacionadas est√°n las responsabilidades de un componente.

### Tipos de Cohesi√≥n

(Ordenados de menor a mayor calidad)

1. **Cohesi√≥n Coincidental**

    Se refiere a la cohesi√≥n donde los elementos est√°n agrupados arbitrariamente.
   - La m√°s d√©bil
   - Elementos sin relaci√≥n real entre s√≠
   - Ejemplo: Clase `Utilidades` con m√©todos miscel√°neos

2. **Cohesi√≥n L√≥gica**
   - Los elementos realizan tareas similares pero no relacionadas
   - Ejemplo: Una clase que maneja todos los tipos de validaciones en el sistema

3. **Cohesi√≥n Temporal**
   - Los elementos se agrupan porque ocurren al mismo tiempo
   - Ejemplo: Una clase `Inicializacion` que configura diferentes partes del sistema

4. **Cohesi√≥n Procedural**
   - Los elementos se agrupan porque siguen una secuencia espec√≠fica
   - Ejemplo: Una clase que maneja el flujo completo de una transacci√≥n

5. **Cohesi√≥n Comunicacional**
   - Los elementos operan sobre los mismos datos
   - Ejemplo: Una clase que realiza diferentes operaciones sobre un mismo conjunto de datos

6. **Cohesi√≥n Secuencial**
   - La salida de un elemento es la entrada del siguiente
   - Ejemplo: Un pipeline de procesamiento de datos

7. **Cohesi√≥n Funcional**
   - La m√°s fuerte
   - Todos los elementos contribuyen a una √∫nica tarea bien definida
   - Ejemplo: Una clase `Autenticador` que solo maneja autenticaci√≥n

### Beneficios de la Alta Cohesi√≥n

1. **Mantenibilidad Mejorada**
   - C√≥digo m√°s f√°cil de entender y modificar
   - Cambios localizados en componentes espec√≠ficos
   - Menor riesgo de efectos secundarios

2. **Reutilizaci√≥n Facilitada**
   - Componentes m√°s independientes
   - Funcionalidad clara y bien definida
   - F√°cil de integrar en diferentes contextos

3. **Testing Simplificado**
   - Pruebas unitarias m√°s enfocadas
   - Menor necesidad de mocks
   - Mayor cobertura de c√≥digo

4. **Mejor Escalabilidad**
   - Facilita la evoluci√≥n del sistema
   - Permite cambios sin afectar otras partes
   - Mejor gesti√≥n de la complejidad

## Acoplamiento

El acoplamiento mide el grado de interdependencia entre m√≥dulos de software. Representa cu√°n fuertemente conectado est√° un m√≥dulo con otros m√≥dulos del sistema.

### Tipos de Acoplamiento

(Ordenados de peor a mejor)

1. **Acoplamiento de Contenido**
   - Un m√≥dulo modifica directamente los datos internos de otro m√≥dulo
   - El peor tipo de acoplamiento
   - Viola el encapsulamiento

2. **Acoplamiento Com√∫n**
   - M√≥dulos comparten variables globales
   - Dif√≠cil de rastrear cambios y efectos secundarios
   - Propenso a errores

3. **Acoplamiento de Control**
   - Un m√≥dulo controla el flujo de otro m√≥dulo
   - Pasa banderas o par√°metros que dictan comportamiento
   - Reduce la reusabilidad

4. **Acoplamiento Temporal**
   - M√≥dulos que deben ejecutarse en un orden espec√≠fico
   - Dependencia en el tiempo de ejecuci√≥n
   - Dif√≠cil de mantener

5. **Acoplamiento de Comunicaci√≥n**
   - M√≥dulos comparten datos a trav√©s de par√°metros
   - M√°s controlado que los anteriores
   - Interfaz clara

6. **Acoplamiento de Datos**
   - Solo se pasan datos simples entre m√≥dulos
   - No hay compartici√≥n de estructuras complejas
   - El m√°s deseable

### Beneficios del Bajo Acoplamiento

1. **Mejor Mantenibilidad**
   - Cambios localizados
   - Menor impacto en otros m√≥dulos

2. **Facilidad de Testing**
   - M√≥dulos independientes
   - F√°cil de mockear dependencias

3. **Mayor Reusabilidad**
   - M√≥dulos independientes
   - F√°cil de reutilizar en diferentes contextos

4. **Mejor Escalabilidad**
   - Facilita cambios y extensiones
   - Menor riesgo de efectos secundarios

## Relaci√≥n entre Cohesi√≥n y Acoplamiento

### Principios Complementarios

- La cohesi√≥n mantiene juntas las cosas relacionadas
- El acoplamiento mantiene independientes los m√≥dulos
- El balance ideal es: Alta Cohesi√≥n + Bajo Acoplamiento

### Impacto Mutuo

- Mejorar la cohesi√≥n suele reducir el acoplamiento
- Reducir el acoplamiento facilita mantener la cohesi√≥n
- Los cambios en uno afectan al otro

## Ejemplos Pr√°cticos

### Ejemplo 1: Baja cohesis√≥n y alto acoplamiento

```typescript
class BaseDatos {
    guardar(coleccion: string, datos: any): void {
        console.log(`Guardando en ${coleccion}:`, datos);
    }
}

class EmailService {
    enviar(destinatario: string, asunto: string, contenido: string): void {
        console.log(`Enviando email a ${destinatario}
            Asunto: ${asunto}
            Contenido: ${contenido}`);
    }
}

class Inventario {
    verificarStock(productoId: string): boolean {
        // Simulaci√≥n de verificaci√≥n de stock
        return true;
    }

    reducirStock(productoId: string, cantidad: number): void {
        console.log(`Reduciendo ${cantidad} unidades del producto ${productoId}`);
    }
}

// Clase que gestiona todo el proceso de compra con baja cohesi√≥n y alto acoplamiento
class GestorProcesoCompra {
    private productos: Array<{id: string, nombre: string, precio: number, cantidad: number}> = [];
    private precioTotal: number = 0;
    private emailCliente: string;
    
    // Alto acoplamiento: La clase crea sus propias dependencias
    private conexionDB = new BaseDatos();
    private emailSender = new EmailService();
    private inventario = new Inventario();

    constructor(emailCliente: string) {
        this.emailCliente = emailCliente;
    }

    agregarProducto(id: string, nombre: string, precio: number, cantidad: number): void {
        this.productos.push({ id, nombre, precio, cantidad });
    }

    // Baja cohesi√≥n: El m√©todo hace demasiadas cosas no relacionadas
    procesarCompra(): void {
        // Validar stock
        for (const producto of this.productos) {
            if (!this.inventario.verificarStock(producto.id)) {
                throw new Error(`Sin stock para el producto ${producto.nombre}`);
            }
        }

        // Calcular precio
        this.calcularPrecioTotal();

        // Actualizar inventario
        for (const producto of this.productos) {
            this.inventario.reducirStock(producto.id, producto.cantidad);
        }

        // Guardar en base de datos
        this.conexionDB.guardar('compras', {
            productos: this.productos,
            total: this.precioTotal,
            email: this.emailCliente,
            fecha: new Date()
        });

        // Enviar email de confirmaci√≥n
        this.emailSender.enviar(
            this.emailCliente,
            'Confirmaci√≥n de Compra',
            `Su compra por $${this.precioTotal} ha sido procesada correctamente. 
             Productos: ${this.productos.map(p => p.nombre).join(', ')}`
        );
    }

    private calcularPrecioTotal(): void {
        this.precioTotal = this.productos.reduce(
            (total, prod) => total + prod.precio * prod.cantidad,
            0
        );
    }

    obtenerTotal(): number {
        return this.precioTotal;
    }
}

// Ejemplo de uso del mal dise√±o
const gestorCompra = new GestorProcesoCompra("cliente@email.com");
gestorCompra.agregarProducto("1", "Laptop", 1200, 1);
gestorCompra.agregarProducto("2", "Mouse", 50, 2);
gestorCompra.procesarCompra();
console.log(`Total de la compra: $${gestorCompra.obtenerTotal()}`);
```

### Ejemplo 2: Buen dise√±o alta cohesi√≥n y bajo acoplamiento

```typescript
// Interfaces claras para cada responsabilidad
interface IInventario {
    verificarStock(productoId: string): boolean;
    reducirStock(productoId: string, cantidad: number): void;
}

interface INotificador {
    notificarOrdenProcesada(email: string, total: number): void;
}

interface IAlmacenamiento {
    guardarOrden(orden: Orden): void;
}

// Clase principal con alta cohesi√≥n: solo maneja la l√≥gica de la orden
class Orden {
    private productos: Producto[] = [];
    private precioTotal: number = 0;

    constructor(
        private emailCliente: string,
        // Bajo acoplamiento: recibe dependencias a trav√©s de interfaces
        private inventario: IInventario,
        private notificador: INotificador,
        private almacenamiento: IAlmacenamiento
    ) {}

    agregarProducto(producto: Producto): void {
        if (this.inventario.verificarStock(producto.id)) {
            this.productos.push(producto);
            this.recalcularTotal();
        } else {
            throw new Error(`Sin stock para producto: ${producto.nombre}`);
        }
    }

    private recalcularTotal(): void {
        this.precioTotal = this.productos.reduce(
            (total, prod) => total + prod.precio * prod.cantidad,
            0
        );
    }

    procesar(): void {
        // Actualizar inventario
        this.actualizarInventario();
        
        // Guardar orden
        this.almacenamiento.guardarOrden(this);
        
        // Notificar al cliente
        this.notificador.notificarOrdenProcesada(this.emailCliente, this.precioTotal);
    }

    private actualizarInventario(): void {
        for (const producto of this.productos) {
            this.inventario.reducirStock(producto.id, producto.cantidad);
        }
    }

    getTotal(): number {
        return this.precioTotal;
    }

    getProductos(): Producto[] {
        return [...this.productos];
    }
}

// Clases de apoyo
class Producto {
    constructor(
        public id: string,
        public nombre: string,
        public precio: number,
        public cantidad: number
    ) {}
}

// Implementaciones concretas
class InventarioDB implements IInventario {
    verificarStock(productoId: string): boolean {
        // L√≥gica real de verificaci√≥n de stock
        return true;
    }

    reducirStock(productoId: string, cantidad: number): void {
        // L√≥gica real de reducci√≥n de stock
        console.log(`Reduciendo ${cantidad} unidades del producto ${productoId}`);
    }
}

class NotificadorEmail implements INotificador {
    notificarOrdenProcesada(email: string, total: number): void {
        console.log(`Enviando email a ${email}: Orden procesada por $${total}`);
    }
}

class AlmacenamientoSQL implements IAlmacenamiento {
    guardarOrden(orden: Orden): void {
        console.log('Guardando orden en SQL:', {
            productos: orden.getProductos(),
            total: orden.getTotal()
        });
    }
}

// Ejemplo de uso
const inventario = new InventarioDB();
const notificador = new NotificadorEmail();
const almacenamiento = new AlmacenamientoSQL();

// Crear orden con dependencias inyectadas
const orden = new Orden(
    "cliente@email.com",
    inventario,
    notificador,
    almacenamiento
);

// Usar la orden
const producto1 = new Producto("1", "Laptop", 1200, 1);
const producto2 = new Producto("2", "Mouse", 50, 2);

orden.agregarProducto(producto1);
orden.agregarProducto(producto2);
orden.procesar();
```

#### Escenarios de solicitudes de cambio

- #### Escenario 1: Cambiar el sistema de notificaciones

    Nuevo requisito: Adem√°s de emails, necesitamos enviar SMS y notificaciones push

  - Con el mal dise√±o:

    - Habr√≠a que modificar la clase principal
    - Riesgo de introducir bugs en la l√≥gica de procesamiento de compra
    - Necesidad de probar toda la clase nuevamente
    - C√≥digo m√°s complejo y dif√≠cil de mantener

  - Con el buen dise√±o:

    ```typescript
    // Simplemente creamos nuevas implementaciones del INotificador
    class NotificadorSMS implements INotificador {
        notificarOrdenProcesada(telefono: string, total: number): void {
            // L√≥gica de SMS
        }
    }

    class NotificadorPush implements INotificador {
        notificarOrdenProcesada(deviceId: string, total: number): void {
            // L√≥gica de Push
        }
    }

    // Y podemos usar m√∫ltiples notificadores sin cambiar la clase Orden
    const notificadores = [
        new NotificadorEmail(),
        new NotificadorSMS(),
        new NotificadorPush()
    ];
    ```

- #### Escenario 2: Cambiar el almacenamiento

    Nuevo requisito: Necesitamos migrar de SQL a MongoDB

  - Con el mal dise√±o:

    - Habr√≠a que modificar la l√≥gica dentro de la clase principal
    - Riesgo de afectar otras funcionalidades
    - Per√≠odo de pruebas m√°s largo
    - Posible tiempo de inactividad durante la migraci√≥n

  - Con el buen dise√±o:

    ```typescript
    class AlmacenamientoMongoDB implements IAlmacenamiento {
    guardarOrden(orden: Orden): void {
        // L√≥gica de MongoDB
        }
    }

    // Podemos incluso implementar una estrategia de migraci√≥n gradual
    class AlmacenamientoDual implements IAlmacenamiento {
        constructor(
            private almacenamientoSQL: AlmacenamientoSQL,
            private almacenamientoMongo: AlmacenamientoMongoDB
        ) {}

        guardarOrden(orden: Orden): void {
            // Guardar en ambos sistemas durante la migraci√≥n
            this.almacenamientoSQL.guardarOrden(orden);
            this.almacenamientoMongo.guardarOrden(orden);
        }
    }
    ```

- #### Escenario 3: Agregar nuevas reglas de negocio

    Nuevo requisito: Necesitamos agregar validaciones de fraude antes de procesar la orden

  - Con el mal dise√±o:

    - Habr√≠a que modificar el m√©todo procesarCompra()
    - Aumentar√≠a la complejidad de una clase ya sobrecargada
    - Mayor riesgo de bugs
    - M√°s dif√≠cil de testear

  - Con el buen dise√±o:

    ```typescript
    interface IValidadorFraude {
        validarOrden(orden: Orden): boolean;
    }

    class ValidadorFraudeBasico implements IValidadorFraude {
        validarOrden(orden: Orden): boolean {
            // L√≥gica de validaci√≥n
            return true;
        }
    }

    // Modificamos la clase Orden de manera limpia
    class Orden {
        constructor(
            private emailCliente: string,
            private inventario: IInventario,
            private notificador: INotificador,
            private almacenamiento: IAlmacenamiento,
            private validadorFraude: IValidadorFraude  // Nueva dependencia
        ) {}

        procesar(): void {
            if (!this.validadorFraude.validarOrden(this)) {
                throw new Error('Posible fraude detectado');
            }
            // Resto del proceso normal...
        }
    }
    ```

#### Ejemplo de soluci√≥n con cambios implementados

```typescript
// =================== INTERFACES BASE ===================
interface INotificador {
    notificarOrdenProcesada(destinatario: string, orden: Orden): void;
}

interface IAlmacenamiento {
    guardarOrden(orden: Orden): Promise<void>;
}

interface IInventario {
    verificarStock(productoId: string): Promise<boolean>;
    reducirStock(productoId: string, cantidad: number): Promise<void>;
}

interface IValidadorFraude {
    validarOrden(orden: Orden): Promise<ValidacionFraude>;
}

// =================== MODELOS ===================
class Producto {
    constructor(
        public id: string,
        public nombre: string,
        public precio: number,
        public cantidad: number
    ) {}
}

class ValidacionFraude {
    constructor(
        public esValida: boolean,
        public motivo?: string
    ) {}
}

// =================== CLASE PRINCIPAL ===================
class Orden {
    private productos: Producto[] = [];
    private precioTotal: number = 0;
    private estado: EstadoOrden = EstadoOrden.CREADA;

    constructor(
        private readonly id: string,
        private readonly emailCliente: string,
        private readonly telefonoCliente: string,
        private readonly inventario: IInventario,
        private readonly notificadores: INotificador[],
        private readonly almacenamiento: IAlmacenamiento,
        private readonly validadorFraude: IValidadorFraude
    ) {}

    async agregarProducto(producto: Producto): Promise<void> {
        const hayStock = await this.inventario.verificarStock(producto.id);
        if (!hayStock) {
            throw new Error(`Sin stock para el producto: ${producto.nombre}`);
        }
        this.productos.push(producto);
        this.recalcularTotal();
    }

    private recalcularTotal(): void {
        this.precioTotal = this.productos.reduce(
            (total, prod) => total + prod.precio * prod.cantidad,
            0
        );
    }

    async procesar(): Promise<void> {
        try {
            // Validar fraude
            const validacionFraude = await this.validadorFraude.validarOrden(this);
            if (!validacionFraude.esValida) {
                throw new Error(`Fraude detectado: ${validacionFraude.motivo}`);
            }

            // Actualizar inventario
            await this.actualizarInventario();
            
            // Guardar orden
            await this.almacenamiento.guardarOrden(this);
            
            // Cambiar estado
            this.estado = EstadoOrden.PROCESADA;

            // Notificar por todos los canales
            await this.notificarCliente();
        } catch (error) {
            this.estado = EstadoOrden.ERROR;
            throw error;
        }
    }

    private async actualizarInventario(): Promise<void> {
        for (const producto of this.productos) {
            await this.inventario.reducirStock(producto.id, producto.cantidad);
        }
    }

    private async notificarCliente(): Promise<void> {
        for (const notificador of this.notificadores) {
            try {
                await notificador.notificarOrdenProcesada(this.emailCliente, this);
            } catch (error) {
                console.error(`Error en notificaci√≥n: ${error.message}`);
                // Continuamos con las dem√°s notificaciones aunque una falle
            }
        }
    }

    // Getters
    getId(): string {
        return this.id;
    }

    getProductos(): Producto[] {
        return [...this.productos];
    }

    getTotal(): number {
        return this.precioTotal;
    }

    getEstado(): EstadoOrden {
        return this.estado;
    }

    getEmailCliente(): string {
        return this.emailCliente;
    }

    getTelefonoCliente(): string {
        return this.telefonoCliente;
    }
}

// =================== IMPLEMENTACIONES DE NOTIFICADORES ===================
class NotificadorEmail implements INotificador {
    async notificarOrdenProcesada(email: string, orden: Orden): Promise<void> {
        console.log(`üìß Enviando email a ${email}:
            Orden: ${orden.getId()}
            Total: $${orden.getTotal()}
            Productos: ${orden.getProductos().map(p => p.nombre).join(', ')}`);
    }
}

class NotificadorSMS implements INotificador {
    async notificarOrdenProcesada(telefono: string, orden: Orden): Promise<void> {
        console.log(`üì± Enviando SMS a ${telefono}:
            Tu orden ${orden.getId()} por $${orden.getTotal()} ha sido procesada.`);
    }
}

class NotificadorPush implements INotificador {
    async notificarOrdenProcesada(deviceId: string, orden: Orden): Promise<void> {
        console.log(`üîî Enviando push notification a ${deviceId}:
            Orden ${orden.getId()} procesada exitosamente.`);
    }
}

// =================== IMPLEMENTACIONES DE ALMACENAMIENTO ===================
class AlmacenamientoSQL implements IAlmacenamiento {
    async guardarOrden(orden: Orden): Promise<void> {
        console.log(`üíæ Guardando orden ${orden.getId()} en SQL`);
    }
}

class AlmacenamientoMongoDB implements IAlmacenamiento {
    async guardarOrden(orden: Orden): Promise<void> {
        console.log(`üçÉ Guardando orden ${orden.getId()} en MongoDB`);
    }
}

class AlmacenamientoDual implements IAlmacenamiento {
    constructor(
        private almacenamientoSQL: AlmacenamientoSQL,
        private almacenamientoMongo: AlmacenamientoMongoDB
    ) {}

    async guardarOrden(orden: Orden): Promise<void> {
        await Promise.all([
            this.almacenamientoSQL.guardarOrden(orden),
            this.almacenamientoMongo.guardarOrden(orden)
        ]);
    }
}

// =================== IMPLEMENTACI√ìN DE INVENTARIO ===================
class InventarioReal implements IInventario {
    async verificarStock(productoId: string): Promise<boolean> {
        console.log(`üì¶ Verificando stock para producto ${productoId}`);
        return true; // Simulado
    }

    async reducirStock(productoId: string, cantidad: number): Promise<void> {
        console.log(`üì¶ Reduciendo ${cantidad} unidades del producto ${productoId}`);
    }
}

// =================== IMPLEMENTACI√ìN DE VALIDADOR DE FRAUDE ===================
class ValidadorFraudeBasico implements IValidadorFraude {
    async validarOrden(orden: Orden): Promise<ValidacionFraude> {
        const total = orden.getTotal();
        
        // Ejemplo de reglas simples de validaci√≥n
        if (total > 10000) {
            return new ValidacionFraude(false, "Monto excede l√≠mite permitido");
        }

        if (orden.getProductos().length > 10) {
            return new ValidacionFraude(false, "Demasiados productos en una sola orden");
        }

        return new ValidacionFraude(true);
    }
}

// =================== ENUMS ===================
enum EstadoOrden {
    CREADA = 'CREADA',
    PROCESADA = 'PROCESADA',
    ERROR = 'ERROR'
}

// =================== EJEMPLO DE USO ===================
async function ejemploUso() {
    try {
        // Crear instancias de servicios
        const inventario = new InventarioReal();
        const notificadores = [
            new NotificadorEmail(),
            new NotificadorSMS(),
            new NotificadorPush()
        ];
        const almacenamiento = new AlmacenamientoDual(
            new AlmacenamientoSQL(),
            new AlmacenamientoMongoDB()
        );
        const validadorFraude = new ValidadorFraudeBasico();

        // Crear orden
        const orden = new Orden(
            "ORD-001",
            "cliente@email.com",
            "+1234567890",
            inventario,
            notificadores,
            almacenamiento,
            validadorFraude
        );

        // Agregar productos
        await orden.agregarProducto(new Producto("1", "Laptop", 1200, 1));
        await orden.agregarProducto(new Producto("2", "Mouse", 50, 2));

        // Procesar orden
        await orden.procesar();

        console.log(`‚úÖ Orden procesada exitosamente. Estado: ${orden.getEstado()}`);
    } catch (error) {
        console.error(`‚ùå Error procesando orden: ${error.message}`);
    }
}

// Ejecutar ejemplo
ejemploUso();
```

## Buenas Pr√°cticas

1. **Principio de Responsabilidad √önica (SRP)**

    - Cada clase debe tener una √∫nica raz√≥n para cambiar.
    - Mantener funcionalidades relacionadas juntas para mejorar la cohesi√≥n.

2. **Inyecci√≥n de Dependencias**

    - Pasar dependencias en lugar de crearlas dentro de la clase.
    - Usar interfaces para desacoplar las dependencias y reducir el acoplamiento.

3. **Interfaces y Abstracci√≥n**

    - Programar hacia interfaces en lugar de implementaciones concretas.
    - Ocultar detalles de implementaci√≥n para reducir el acoplamiento y facilitar cambios.

4. **Encapsulamiento**

    - Minimizar la exposici√≥n de detalles internos de las clases.
    - Proteger el estado interno para mantener la cohesi√≥n y reducir el acoplamiento.

5. **Cohesi√≥n Funcional**

    - Asegurarse de que todos los elementos de un m√≥dulo contribuyan a una √∫nica tarea bien definida.
    - Evitar mezclar responsabilidades no relacionadas dentro de un mismo m√≥dulo.

6. **Desacoplamiento de M√≥dulos**

    - Dise√±ar m√≥dulos que interact√∫en a trav√©s de interfaces bien definidas.
    - Evitar dependencias directas entre m√≥dulos para reducir el acoplamiento.

7. **Segregaci√≥n de Interfaces (ISP)**

    - Crear interfaces espec√≠ficas para cada cliente en lugar de interfaces generales.
    - Asegurar que las clases no dependan de m√©todos que no utilizan, reduciendo el acoplamiento.

8. **Principio de Inversi√≥n de Dependencias (DIP)**

    - Depender de abstracciones en lugar de concreciones.
    - Facilitar la sustituci√≥n de implementaciones sin afectar a los m√≥dulos dependientes.

  Estas pr√°cticas ayudan a mantener una alta cohesi√≥n y un bajo acoplamiento, lo que resulta en sistemas m√°s mantenibles, flexibles y robustos.

## M√©tricas

### M√©tricas de Cohesi√≥n

1. **LCOM (Lack of Cohesion of Methods)**

   - Mide la disparidad entre m√©todos de una clase
   - Menor valor indica mayor cohesi√≥n

2. **TCC (Tight Class Cohesion)**
   - Mide relaciones directas entre m√©todos
   - Mayor valor indica mayor cohesi√≥n

### M√©tricas de Acoplamiento

1. **Acoplamiento Aferente (Ca)**

- Mide dependencias entrantes a una clase o m√≥dulo
- Menor valor indica menor acoplamiento con otras clases o m√≥dulos 

2. **Acoplamiento Eferente (Ce)**

- Mide dependencias salientes de una clase o m√≥dulo 
- Menor valor indica menor acoplamiento con otras clases o m√≥dulos 

3. **Instabilidad (I)**

- Mide la cantidad de dependencias entrantes y salientes de una clase o m√≥dulo
- Valores cercanos a 0 indican alta estabilidad
- Valores cercanos a 1 indican alta inestabilidad

   - I = Ce / (Ca + Ce)
   - 0 = m√°xima estabilidad
   - 1 = m√°xima inestabilidad
